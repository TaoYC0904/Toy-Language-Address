Require Import Toy.Imp Toy.Language.
Require Import Toy.UnifySL.implementation.
Import T.

Module Assertion_Shallow.
Import Denote_Aexp.
Import Denote_Bexp.
Import Denote_Com.
Import Denote_State.

Definition exp {A : Type} (P : A -> Assertion) : Assertion := fun st => exists a, P a st.

Definition inj (b : bexp) : Assertion := fun st => true_set (beval b) (fst st).

Definition eqp (a : aexp) (v : Z) : Assertion := fun st => (aeval a) (fst st) = Some v.

Definition safea (a : aexp) : Assertion := fun st => ~ (aeval a) (fst st) = None.

Definition safeb (b : bexp) : Assertion := fun st => ~ error_set (beval b) (fst st).

Definition mapsto_ (p : addr) : Assertion := fun st => (exists v, (snd st) p = Some v) /\ (forall p', p <> p' -> (snd st) p' = None).

Definition mapsto (p : addr) (v : Z) : Assertion := fun st => (snd st) p = Some v /\ (forall p', p <> p' -> (snd st) p' = None).

Definition derives : Assertion -> Assertion -> Prop := fun P Q => forall st, P st -> Q st.

Definition store_update (s : store) (X : var) (v : option Z) : store :=
  match v with
  | Some n => fun Y => if (Nat.eq_dec Y X) then n else s Y
  | None => fun Y => 0
  end.

Definition heap_update (h : heap) (p : addr) (v : option Z) : heap :=
  fun q => if (Z.eq_dec p q) then v else h q.

Definition subst_set (P : Assertion) (X : var) (v : Z) : Assertion :=
  fun st => P (store_update (fst st) X (Some v), snd st).

Definition subst_load (P : Assertion) (X : var) (v : Z) : Assertion :=
  fun st => P (store_update (fst st) X (Some v), snd st).

(* Definition join_heap : heap -> heap -> heap -> Prop :=
  fun h1 h2 h3 => 
    forall p : Z,
      (exists v, h1 p = Some v /\ h2 p = None /\ h3 p = Some v) \/
      (exists v, h1 p = None /\ h2 p = Some v /\ h3 p = Some v) \/
      (h1 p = None /\ h2 p = None /\ h3 p = None).

Definition join : state -> state -> state -> Prop :=
  fun st1 st2 st3 => fst st1 = fst st2 /\ fst st2 = fst st3 /\ join_heap (snd st1) (snd st2) (snd st3).

Definition sepcon (P Q : Assertion) : Assertion :=
  fun st => exists st1 st2, join st1 st2 st /\ P st1 /\ Q st2. *)
End Assertion_Shallow.

Module Validity.
Import Denote_State.
Import Assertion_Shallow.
Import Denote_Com.

Definition valid (P : Assertion) (c : com) (Q Rb Rc : Assertion) : Prop :=
  forall st1 st2, P st1 ->
    (~ com_error (ceval c) st1) /\
    (com_normal (ceval c) st1 st2 -> Q st2) /\
    (com_break (ceval c) st1 st2 -> Rb st2) /\
    (com_cont (ceval c) st1 st2 -> Rc st2).

End Validity.

Module temp.

Ltac UFsepcon := unfold sepcon; 
                 unfold WeakSemantics.WeakSemantics.sepcon;
                 unfold SeparationAlgebra.join.

Ltac UFjoin := unfold stateJ; unfold stateJoin;
               unfold OSAGenerators.prod_Join;
               unfold SeparationAlgebra.join;
               unfold store_join;
               unfold OSAGenerators.equiv_Join.
(* 
Lemma osajoin : forall (st1 st2 st : state), 
  (forall x, OSAGenerators.option_join Z 
          (snd st1 x) (snd st2 x) (snd st x)) -> 
  (forall p, (exists v, snd st1 p = Some v /\ snd st2 p = None /\ snd st p = Some v) \/
             (exists v, snd st1 p = None /\ snd st2 p = Some v /\ snd st p = Some v) \/
             (snd st1 p = None ) /\ (snd st2 p = None) /\ (snd st p = None)). 
 *)
Import Assertion_Shallow.
Goal forall P Q st, (sepcon P Q) st.
Proof.
  UFsepcon.
  UFjoin.
  unfold heap_join.
  unfold OSAExamples.Heap_Join.
  unfold OSAGenerators.fun_Join.
  unfold SeparationAlgebra.join.
  unfold OSAGenerators.option_Join.
  intros. exists st, st. split.
  + split. admit.
    intros.
     
  (* unfold OSAGenerators.option_join. *)
Admitted.

End temp.

